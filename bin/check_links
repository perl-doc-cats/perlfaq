#!/usr/bin/perl
use v5.36;
use strict;
use warnings;

=head1 NAME

bin/check_links - verify the links in the perlfaq

=head1 SYNOPSIS

	# check all the links in
	perl bin/check_links

	# check a single perlfaq page, just specify the number
	perl bin/check_links 3

	# check a range with the min and max
	perl bin/check_links 3 6

	# see all the errors at the end
	perl bin/check_links | sort

=head1 DESCRIPTION

This program extracts the links from all the perlfaq pages then tries
to fetch them. It reports the HTTP status, the perlfaq page, and the
link. In the case of a redirect response, it also reports the Location
value.

Note that redirections sometimes leads to more redirections, which this
does not handle. Sometimes those chains lead to dead links, or even
cycles.

If the program cannot connect to a server, it reports a 500
status. This does not mean the link is bad since this could be a local
network hiccup.

If there are any bad links (permanent redirects, or any 4xx or 5xx
statuses), this program exits with a non-zero value. If no links are
bad, it exits with 0.

=head1 AUTHOR

brian d foy, bdfoy@cpan.org

=head1 LICENSE

You can use and distribute this under the same terms as perl. A LICENSE
file is included with the perlfaq repository.

=cut

use File::Spec::Functions;
use Mojo::Promise;
use Mojo::UserAgent;
use Mojo::Util qw(dumper);

@ARGV = ( 1, 9 ) unless @ARGV;
my( $min, $max ) = @ARGV;
$max //= $min;

my $ua = Mojo::UserAgent->new;
$ua->inactivity_timeout(10);

my $Checked = {};

sub print_status ( $code, $section, $link, $redirect = undef ) {
	printf "%3d  %8s  %s%s\n",  $code, $section, $link,
		defined $redirect ? ' -> ' . $redirect : '';
		;
	}

my @promises =
	map {
		my $t = $_;

		my $success = sub ($tx) {
			$Checked->{$t->{link}}{code} = $tx->res->code;
			$Checked->{$t->{link}}{count}++;
			$Checked->{$t->{link}}{location} = $tx->res->headers->location;
			print_status( $tx->res->code, $t->{section}, $t->{link}, $tx->res->headers->location )
			};

		my $error = sub ($err) {
			$Checked->{$t->{link}}{code} = 500;
			$Checked->{$t->{link}}{count}++;
			print_status( 500, $t->{section}, $t->{link}, undef )
			};

		my $promise = $ua->get_p( $t->{link} )->then(
			$success,
			$error,
			);
		}
	map {
		my $section = "perlfaq$_";
		my $path = catfile( 'lib', "$section.pod" );
		my $contents = Mojo::File->new( $path )->slurp;
		my @links = $contents =~ m|L<(?:[^>]+?\|)?(https?://.+?)>|ig;
		map { { section => $section, path => $path, link => $_ } } @links;
		}
	$min .. $max;

my $all = Mojo::Promise->all_settled( @promises );
$all->wait;

my $Errors = () = grep { $_->{code} =~ m/30[18]|[45]\d\d/  } values $Checked->%*;

exit( $Errors ? 1 : 0 );
